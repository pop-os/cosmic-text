<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate gives small utilities for casting between plain data types."><title>bytemuck - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bytemuck" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../bytemuck/index.html">bytemuck</a><span class="version">1.24.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#basics" title="Basics">Basics</a></li><li><a href="#failures" title="Failures">Failures</a></li><li><a href="#using-your-own-types" title="Using Your Own Types">Using Your Own Types</a></li><li><a href="#cargo-features" title="Cargo Features">Cargo Features</a></li><li><a href="#related-crates" title="Related Crates">Related Crates</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#derives" title="Derive Macros">Derive Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>bytemuck</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/bytemuck/lib.rs.html#1-578">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate gives small utilities for casting between plain data types.</p>
<h3 id="basics"><a class="doc-anchor" href="#basics">§</a>Basics</h3>
<p>Data comes in five basic forms in Rust, so we have five basic casting
functions:</p>
<ul>
<li><code>T</code> uses <a href="fn.cast.html" title="fn bytemuck::cast"><code>cast</code></a></li>
<li><code>&amp;T</code> uses <a href="fn.cast_ref.html" title="fn bytemuck::cast_ref"><code>cast_ref</code></a></li>
<li><code>&amp;mut T</code> uses <a href="fn.cast_mut.html" title="fn bytemuck::cast_mut"><code>cast_mut</code></a></li>
<li><code>&amp;[T]</code> uses <a href="fn.cast_slice.html" title="fn bytemuck::cast_slice"><code>cast_slice</code></a></li>
<li><code>&amp;mut [T]</code> uses <a href="fn.cast_slice_mut.html" title="fn bytemuck::cast_slice_mut"><code>cast_slice_mut</code></a></li>
</ul>
<p>Depending on the function, the <a href="trait.NoUninit.html" title="trait bytemuck::NoUninit"><code>NoUninit</code></a> and/or <a href="trait.AnyBitPattern.html" title="trait bytemuck::AnyBitPattern"><code>AnyBitPattern</code></a> traits
are used to maintain memory safety.</p>
<p><strong>Historical Note:</strong> When the crate first started the <a href="trait.Pod.html" title="trait bytemuck::Pod"><code>Pod</code></a> trait was used
instead, and so you may hear people refer to that, but it has the strongest
requirements and people eventually wanted the more fine-grained system, so
here we are. All types that impl <code>Pod</code> have a blanket impl to also support
<code>NoUninit</code> and <code>AnyBitPattern</code>. The traits unfortunately do not have a
perfectly clean hierarchy for semver reasons.</p>
<h3 id="failures"><a class="doc-anchor" href="#failures">§</a>Failures</h3>
<p>Some casts will never fail, and other casts might fail.</p>
<ul>
<li><code>cast::&lt;u32, f32&gt;</code> always works (and <a href="https://doc.rust-lang.org/1.90.0/core/primitive.f32.html#method.from_bits" title="associated function f32::from_bits"><code>f32::from_bits</code></a>).</li>
<li><code>cast_ref::&lt;[u8; 4], u32&gt;</code> might fail if the specific array reference
given at runtime doesn’t have alignment 4.</li>
</ul>
<p>In addition to the “normal” forms of each function, which will panic on
invalid input, there’s also <code>try_</code> versions which will return a <code>Result</code>.</p>
<p>If you would like to statically ensure that a cast will work at runtime you
can use the <code>must_cast</code> crate feature and the <code>must_</code> casting functions. A
“must cast” that can’t be statically known to be valid will cause a
compilation error (and sometimes a very hard to read compilation error).</p>
<h3 id="using-your-own-types"><a class="doc-anchor" href="#using-your-own-types">§</a>Using Your Own Types</h3>
<p>All the functions listed above are guarded by the <a href="trait.Pod.html" title="trait bytemuck::Pod"><code>Pod</code></a> trait, which is a
sub-trait of the <a href="trait.Zeroable.html" title="trait bytemuck::Zeroable"><code>Zeroable</code></a> trait.</p>
<p>If you enable the crate’s <code>derive</code> feature then these traits can be derived
on your own types. The derive macros will perform the necessary checks on
your type declaration, and trigger an error if your type does not qualify.</p>
<p>The derive macros might not cover all edge cases, and sometimes they will
error when actually everything is fine. As a last resort you can impl these
traits manually. However, these traits are <code>unsafe</code>, and you should
carefully read the requirements before using a manual implementation.</p>
<h3 id="cargo-features"><a class="doc-anchor" href="#cargo-features">§</a>Cargo Features</h3>
<p>The crate supports Rust 1.34 when no features are enabled, and so there’s
cargo features for thing that you might consider “obvious”.</p>
<p>The cargo features <strong>do not</strong> promise any particular MSRV, and they may
increase their MSRV in new versions.</p>
<ul>
<li><code>derive</code>: Provide derive macros for the various traits.</li>
<li><code>extern_crate_alloc</code>: Provide utilities for <code>alloc</code> related types such as
Box and Vec.</li>
<li><code>zeroable_maybe_uninit</code> and <code>zeroable_atomics</code>: Provide more <a href="trait.Zeroable.html" title="trait bytemuck::Zeroable"><code>Zeroable</code></a>
impls.</li>
<li><code>pod_saturating</code>: Provide more <a href="trait.Pod.html" title="trait bytemuck::Pod"><code>Pod</code></a> and <a href="trait.Zeroable.html" title="trait bytemuck::Zeroable"><code>Zeroable</code></a> impls.</li>
<li><code>wasm_simd</code> and <code>aarch64_simd</code>: Support more SIMD types.</li>
<li><code>min_const_generics</code>: Provides appropriate impls for arrays of all lengths
instead of just for a select list of array lengths.</li>
<li><code>must_cast</code>: Provides the <code>must_</code> functions, which will compile error if
the requested cast can’t be statically verified.</li>
<li><code>const_zeroed</code>: Provides a const version of the <code>zeroed</code> function.</li>
</ul>
<h3 id="related-crates"><a class="doc-anchor" href="#related-crates">§</a>Related Crates</h3>
<ul>
<li><a href="https://docs.rs/pack1"><code>pack1</code></a>, which contains <code>bytemuck</code>-compatible
packed little-endian, big-endian and native-endian integer and floating
point number types.</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.CheckedBitPattern"><code>pub use checked::<a class="trait" href="checked/trait.CheckedBitPattern.html" title="trait bytemuck::checked::CheckedBitPattern">CheckedBitPattern</a>;</code></dt><dt><code>pub use <a class="mod" href="allocation/index.html" title="mod bytemuck::allocation">allocation</a>::*;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="allocation/index.html" title="mod bytemuck::allocation">allocation</a></dt><dd>Stuff to boost things in the <code>alloc</code> crate.</dd><dt><a class="mod" href="checked/index.html" title="mod bytemuck::checked">checked</a></dt><dd>Checked versions of the casting functions exposed in crate root
that support <a href="checked/trait.CheckedBitPattern.html" title="trait bytemuck::checked::CheckedBitPattern"><code>CheckedBitPattern</code></a> types.</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.offset_of.html" title="macro bytemuck::offset_of">offset_<wbr>of</a></dt><dd>Find the offset in bytes of the given <code>$field</code> of <code>$Type</code>. Requires an
already initialized <code>$instance</code> value to work with.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.PodCastError.html" title="enum bytemuck::PodCastError">PodCast<wbr>Error</a></dt><dd>The things that can go wrong when casting between <a href="trait.Pod.html" title="trait bytemuck::Pod"><code>Pod</code></a> data forms.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.AnyBitPattern.html" title="trait bytemuck::AnyBitPattern">AnyBit<wbr>Pattern</a></dt><dd>Marker trait for “plain old data” types that are valid for any bit pattern.</dd><dt><a class="trait" href="trait.Contiguous.html" title="trait bytemuck::Contiguous">Contiguous</a></dt><dd>A trait indicating that:</dd><dt><a class="trait" href="trait.NoUninit.html" title="trait bytemuck::NoUninit">NoUninit</a></dt><dd>Marker trait for “plain old data” types with no uninit (or padding) bytes.</dd><dt><a class="trait" href="trait.Pod.html" title="trait bytemuck::Pod">Pod</a></dt><dd>Marker trait for “plain old data”.</dd><dt><a class="trait" href="trait.PodInOption.html" title="trait bytemuck::PodInOption">PodIn<wbr>Option</a></dt><dd>Trait for types which are <a href="trait.Pod.html" title="trait bytemuck::Pod">Pod</a> when wrapped in
<a href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>.</dd><dt><a class="trait" href="trait.TransparentWrapper.html" title="trait bytemuck::TransparentWrapper">Transparent<wbr>Wrapper</a></dt><dd>A trait which indicates that a type is a <code>#[repr(transparent)]</code> wrapper
around the <code>Inner</code> value.</dd><dt><a class="trait" href="trait.Zeroable.html" title="trait bytemuck::Zeroable">Zeroable</a></dt><dd>Trait for types that can be safely created with
<a href="https://doc.rust-lang.org/1.90.0/core/mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>zeroed</code></a>.</dd><dt><a class="trait" href="trait.ZeroableInOption.html" title="trait bytemuck::ZeroableInOption">Zeroable<wbr>InOption</a></dt><dd>Trait for types which are <a href="trait.Zeroable.html" title="trait bytemuck::Zeroable">Zeroable</a> when wrapped in
<a href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.bytes_of.html" title="fn bytemuck::bytes_of">bytes_<wbr>of</a></dt><dd>Re-interprets <code>&amp;T</code> as <code>&amp;[u8]</code>.</dd><dt><a class="fn" href="fn.bytes_of_mut.html" title="fn bytemuck::bytes_of_mut">bytes_<wbr>of_<wbr>mut</a></dt><dd>Re-interprets <code>&amp;mut T</code> as <code>&amp;mut [u8]</code>.</dd><dt><a class="fn" href="fn.cast.html" title="fn bytemuck::cast">cast</a></dt><dd>Cast <code>A</code> into <code>B</code></dd><dt><a class="fn" href="fn.cast_mut.html" title="fn bytemuck::cast_mut">cast_<wbr>mut</a></dt><dd>Cast <code>&amp;mut A</code> into <code>&amp;mut B</code>.</dd><dt><a class="fn" href="fn.cast_ref.html" title="fn bytemuck::cast_ref">cast_<wbr>ref</a></dt><dd>Cast <code>&amp;A</code> into <code>&amp;B</code>.</dd><dt><a class="fn" href="fn.cast_slice.html" title="fn bytemuck::cast_slice">cast_<wbr>slice</a></dt><dd>Cast <code>&amp;[A]</code> into <code>&amp;[B]</code>.</dd><dt><a class="fn" href="fn.cast_slice_mut.html" title="fn bytemuck::cast_slice_mut">cast_<wbr>slice_<wbr>mut</a></dt><dd>Cast <code>&amp;mut [A]</code> into <code>&amp;mut [B]</code>.</dd><dt><a class="fn" href="fn.fill_zeroes.html" title="fn bytemuck::fill_zeroes">fill_<wbr>zeroes</a></dt><dd>Fill all bytes of <code>slice</code> with zeroes (see <a href="trait.Zeroable.html" title="trait bytemuck::Zeroable"><code>Zeroable</code></a>).</dd><dt><a class="fn" href="fn.from_bytes.html" title="fn bytemuck::from_bytes">from_<wbr>bytes</a></dt><dd>Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.</dd><dt><a class="fn" href="fn.from_bytes_mut.html" title="fn bytemuck::from_bytes_mut">from_<wbr>bytes_<wbr>mut</a></dt><dd>Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.</dd><dt><a class="fn" href="fn.pod_align_to.html" title="fn bytemuck::pod_align_to">pod_<wbr>align_<wbr>to</a></dt><dd>As <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to"><code>align_to</code></a>,
but safe because of the <a href="trait.Pod.html" title="trait bytemuck::Pod"><code>Pod</code></a> bound.</dd><dt><a class="fn" href="fn.pod_align_to_mut.html" title="fn bytemuck::pod_align_to_mut">pod_<wbr>align_<wbr>to_<wbr>mut</a></dt><dd>As <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut"><code>align_to_mut</code></a>,
but safe because of the <a href="trait.Pod.html" title="trait bytemuck::Pod"><code>Pod</code></a> bound.</dd><dt><a class="fn" href="fn.pod_read_unaligned.html" title="fn bytemuck::pod_read_unaligned">pod_<wbr>read_<wbr>unaligned</a></dt><dd>Reads the slice into a <code>T</code> value.</dd><dt><a class="fn" href="fn.try_cast.html" title="fn bytemuck::try_cast">try_<wbr>cast</a></dt><dd>Try to cast <code>A</code> into <code>B</code>.</dd><dt><a class="fn" href="fn.try_cast_mut.html" title="fn bytemuck::try_cast_mut">try_<wbr>cast_<wbr>mut</a></dt><dd>Try to convert a <code>&amp;mut A</code> into <code>&amp;mut B</code>.</dd><dt><a class="fn" href="fn.try_cast_ref.html" title="fn bytemuck::try_cast_ref">try_<wbr>cast_<wbr>ref</a></dt><dd>Try to convert a <code>&amp;A</code> into <code>&amp;B</code>.</dd><dt><a class="fn" href="fn.try_cast_slice.html" title="fn bytemuck::try_cast_slice">try_<wbr>cast_<wbr>slice</a></dt><dd>Try to convert <code>&amp;[A]</code> into <code>&amp;[B]</code> (possibly with a change in length).</dd><dt><a class="fn" href="fn.try_cast_slice_mut.html" title="fn bytemuck::try_cast_slice_mut">try_<wbr>cast_<wbr>slice_<wbr>mut</a></dt><dd>Try to convert <code>&amp;mut [A]</code> into <code>&amp;mut [B]</code> (possibly with a change in
length).</dd><dt><a class="fn" href="fn.try_from_bytes.html" title="fn bytemuck::try_from_bytes">try_<wbr>from_<wbr>bytes</a></dt><dd>Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.</dd><dt><a class="fn" href="fn.try_from_bytes_mut.html" title="fn bytemuck::try_from_bytes_mut">try_<wbr>from_<wbr>bytes_<wbr>mut</a></dt><dd>Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.</dd><dt><a class="fn" href="fn.try_pod_read_unaligned.html" title="fn bytemuck::try_pod_read_unaligned">try_<wbr>pod_<wbr>read_<wbr>unaligned</a></dt><dd>Reads from the bytes as if they were a <code>T</code>.</dd><dt><a class="fn" href="fn.write_zeroes.html" title="fn bytemuck::write_zeroes">write_<wbr>zeroes</a></dt><dd>Fill all bytes of <code>target</code> with zeroes (see <a href="trait.Zeroable.html" title="trait bytemuck::Zeroable"><code>Zeroable</code></a>).</dd></dl><h2 id="derives" class="section-header">Derive Macros<a href="#derives" class="anchor">§</a></h2><dl class="item-table"><dt><a class="derive" href="derive.AnyBitPattern.html" title="derive bytemuck::AnyBitPattern">AnyBit<wbr>Pattern</a></dt><dd>Derive the <code>AnyBitPattern</code> trait for a struct</dd><dt><a class="derive" href="derive.ByteEq.html" title="derive bytemuck::ByteEq">ByteEq</a></dt><dd>Derive the <code>PartialEq</code> and <code>Eq</code> trait for a type</dd><dt><a class="derive" href="derive.ByteHash.html" title="derive bytemuck::ByteHash">Byte<wbr>Hash</a></dt><dd>Derive the <code>Hash</code> trait for a type</dd><dt><a class="derive" href="derive.CheckedBitPattern.html" title="derive bytemuck::CheckedBitPattern">Checked<wbr>BitPattern</a></dt><dd>Derive the <code>CheckedBitPattern</code> trait for a struct or enum.</dd><dt><a class="derive" href="derive.Contiguous.html" title="derive bytemuck::Contiguous">Contiguous</a></dt><dd>Derive the <code>Contiguous</code> trait for an enum</dd><dt><a class="derive" href="derive.NoUninit.html" title="derive bytemuck::NoUninit">NoUninit</a></dt><dd>Derive the <code>NoUninit</code> trait for a struct or enum</dd><dt><a class="derive" href="derive.Pod.html" title="derive bytemuck::Pod">Pod</a></dt><dd>Derive the <code>Pod</code> trait for a struct</dd><dt><a class="derive" href="derive.TransparentWrapper.html" title="derive bytemuck::TransparentWrapper">Transparent<wbr>Wrapper</a></dt><dd>Derive the <code>TransparentWrapper</code> trait for a struct</dd><dt><a class="derive" href="derive.Zeroable.html" title="derive bytemuck::Zeroable">Zeroable</a></dt><dd>Derive the <code>Zeroable</code> trait for a type.</dd></dl></section></div></main></body></html>