<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides a high performance, low level 2D rasterization library with support for rendering paths of various styles into alpha or subpixel masks."><title>zeno - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="zeno" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../zeno/index.html">zeno</a><span class="version">0.3.3</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#rendering" title="Rendering">Rendering</a></li><li><a href="#hit-testing" title="Hit testing">Hit testing</a></li><li><a href="#path-building" title="Path building">Path building</a></li><li><a href="#traversal" title="Traversal">Traversal</a></li><li><a href="#transient-memory-allocations" title="Transient memory allocations">Transient memory allocations</a></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>zeno</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/zeno/lib.rs.html#1-382">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides a high performance, low level 2D rasterization library
with support for rendering paths of various styles into alpha or subpixel
masks.</p>
<p>Broadly speaking, support is provided for the following:</p>
<ul>
<li>256x anti-aliased rasterization (8-bit alpha or 32-bit RGBA subpixel alpha)</li>
<li>Pixel perfect hit testing with customizable coverage threshold</li>
<li>Non-zero and even-odd fills</li>
<li>Stroking with the standard set of joins and caps
(separate start and end caps are possible)</li>
<li>Numerically stable dashing for smooth dash offset animation</li>
<li>Vertex traversal for marker placement</li>
<li>Stepped distance traversal for animation or text-on-path support</li>
<li>Abstract representation of path data that imposes no policy on storage</li>
</ul>
<p>While this crate is general purpose, in the interest of interoperability and
familiarity, the feature set was chosen specifically to accommodate the
requirements of the
<a href="https://www.w3.org/TR/SVG/paths.html">SVG path specification</a>.</p>
<p>Furthermore, the rasterized masks are nearly identical to those generated by
Skia (sans slight AA differences) and as such, should yield images that are
equivalent to those produced by modern web browsers.</p>
<h2 id="rendering"><a class="doc-anchor" href="#rendering">§</a>Rendering</h2>
<p>Due to the large configuration space for styling and rendering paths, the
builder pattern is used pervasively. The <a href="struct.Mask.html" title="struct zeno::Mask"><code>Mask</code></a> struct is the builder
used for rasterization. For example, to render a simple triangle into a
64x64 8-bit alpha mask:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Mask, PathData};

<span class="comment">// The target buffer that will contain the mask
</span><span class="kw">let </span><span class="kw-2">mut </span>mask = [<span class="number">0u8</span>; <span class="number">64 </span>* <span class="number">64</span>];

<span class="comment">// Create a new mask with some path data
</span>Mask::new(<span class="string">"M 8,56 32,8 56,56 Z"</span>)
    <span class="comment">// Choose an explicit size for the target
    </span>.size(<span class="number">64</span>, <span class="number">64</span>)
    <span class="comment">// Finally, render the path into the target
    </span>.render_into(<span class="kw-2">&amp;mut </span>mask, <span class="prelude-val">None</span>);</code></pre></div>
<p>Note that, in this case, the path itself is supplied as a string in SVG path
data format. This crate provides several different kinds of path data by
default along with support for custom implementations. See the
<a href="trait.PathData.html" title="trait zeno::PathData"><code>PathData</code></a> trait for more detail.</p>
<p>The previous example did not provide a style, so a non-zero
<a href="enum.Fill.html" title="enum zeno::Fill"><code>Fill</code></a> was chosen by default. Let’s render the same path with
a 4 pixel wide stroke and a round line join:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Join, Mask, PathData, Stroke};

<span class="kw">let </span><span class="kw-2">mut </span>mask = [<span class="number">0u8</span>; <span class="number">64 </span>* <span class="number">64</span>];

Mask::new(<span class="string">"M 8,56 32,8 56,56 Z"</span>)
    .size(<span class="number">64</span>, <span class="number">64</span>)
    .style(Stroke::new(<span class="number">4.0</span>).join(Join::Round))
    .render_into(<span class="kw-2">&amp;mut </span>mask, <span class="prelude-val">None</span>);</code></pre></div>
<p>Or to make it a bit more dashing:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Cap, Join, Mask, PathData, Stroke};

<span class="kw">let </span><span class="kw-2">mut </span>mask = [<span class="number">0u8</span>; <span class="number">64 </span>* <span class="number">64</span>];

Mask::new(<span class="string">"M 8,56 32,8 56,56 Z"</span>)
    .style(
        Stroke::new(<span class="number">4.0</span>)
            .join(Join::Round)
            .cap(Cap::Round)
            <span class="comment">// dash accepts a slice of dash lengths and an initial dash offset
            </span>.dash(<span class="kw-2">&amp;</span>[<span class="number">10.0</span>, <span class="number">12.0</span>, <span class="number">0.0</span>], <span class="number">0.0</span>),
    )
    .size(<span class="number">64</span>, <span class="number">64</span>)
    .render_into(<span class="kw-2">&amp;mut </span>mask, <span class="prelude-val">None</span>);</code></pre></div>
<p>See the <a href="struct.Stroke.html" title="struct zeno::Stroke"><code>Stroke</code></a> builder struct for all available options.</p>
<p>So far, we’ve generated our masks into fixed buffers with explicit sizes. It is
often the case that it is preferred to ignore all empty space and render a path
into a tightly bound mask of dynamic size. This can be done by eliding the call
for the size method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Mask, PathData};

<span class="comment">// Dynamic buffer that will contain the mask
</span><span class="kw">let </span><span class="kw-2">mut </span>mask = Vec::new();

<span class="kw">let </span>placement = Mask::new(<span class="string">"M 8,56 32,8 56,56 Z"</span>)
    <span class="comment">// Insert an inspect call here to access the computed dimensions
    </span>.inspect(|format, width, height| {
        <span class="comment">// Make sure our buffer is the correct size
        </span>mask.resize(format.buffer_size(width, height), <span class="number">0</span>);
    })
    .render_into(<span class="kw-2">&amp;mut </span>mask, <span class="prelude-val">None</span>);</code></pre></div>
<p>The call to size has been replaced with a call to inspect which injects a
closure into the call chain giving us the opportunity to extend our buffer to
the appropriate size. Note also that the render method has a return value that
has been captured here. This <a href="struct.Placement.html" title="struct zeno::Placement"><code>Placement</code></a> struct describes the dimensions of
the resulting mask along with an offset that should be applied during
composition to compensate for the removal of any empty space.</p>
<p>Finally, it is possible to render without a target buffer, in which case the
rasterizer will allocate and return a new <code>Vec&lt;u8&gt;</code> containing the mask:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Mask, PathData};

<span class="comment">// mask is a Vec&lt;u8&gt;
</span><span class="kw">let </span>(mask, placement) = Mask::new(<span class="string">"M 8,56 32,8 56,56 Z"</span>)
    <span class="comment">// Calling render() instead of render_into() will allocate a buffer
    // for you that is returned along with the placement
    </span>.render();</code></pre></div>
<p>Both <a href="struct.Mask.html" title="struct zeno::Mask"><code>Mask</code></a> and <a href="struct.Stroke.html" title="struct zeno::Stroke"><code>Stroke</code></a> offer large sets of options for fine-grained
control of styling and rasterization including offsets, scaling,
transformations, formats, coordinate spaces and more. See
their respective documentation for more detail.</p>
<h2 id="hit-testing"><a class="doc-anchor" href="#hit-testing">§</a>Hit testing</h2>
<p>Hit testing is the process of determining if a point is within the region that
would be painted by the path. A typical use case is to determine if a user’s
cursor is hovering over a particular path. The process generally follows the
same form as rendering:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{HitTest, PathData};

<span class="comment">// A 20x10 region with the right half covered by the path
</span><span class="kw">let </span>hit_test = HitTest::new(<span class="string">"M10,0 10,10 20,10 20,0 Z"</span>);

<span class="macro">assert_eq!</span>(hit_test.test([<span class="number">15</span>, <span class="number">5</span>]), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(hit_test.test([<span class="number">5</span>, <span class="number">5</span>]), <span class="bool-val">false</span>);</code></pre></div>
<p>Due to the fact that paths are anti-aliased, the hit test builder offers a
threshold option that determines how much “coverage” is required for a hit test
to pass at a particular point.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{HitTest, PathData};

<span class="kw">let </span><span class="kw-2">mut </span>hit_test = HitTest::new(<span class="string">"M2.5,0 2.5,2 5,2 5,0 Z"</span>);

<span class="comment">// Require full coverage for a successful hit test
</span>hit_test.threshold(<span class="number">255</span>);
<span class="macro">assert_eq!</span>(hit_test.test([<span class="number">2</span>, <span class="number">0</span>]), <span class="bool-val">false</span>);

<span class="comment">// Succeed for any non-zero coverage
</span>hit_test.threshold(<span class="number">0</span>);
<span class="macro">assert_eq!</span>(hit_test.test([<span class="number">2</span>, <span class="number">0</span>]), <span class="bool-val">true</span>);</code></pre></div>
<p>See the <a href="struct.HitTest.html" title="struct zeno::HitTest"><code>HitTest</code></a> type for more detail.</p>
<h2 id="path-building"><a class="doc-anchor" href="#path-building">§</a>Path building</h2>
<p>While SVG paths are a reasonable choice for static storage, there sometimes
arise cases where paths must be built dynamically at runtime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Command, Mask, PathBuilder, PathData};

<span class="comment">// Create a vector to store the path commands
</span><span class="kw">let </span><span class="kw-2">mut </span>path: Vec&lt;Command&gt; = Vec::new();

<span class="comment">// Construct the path with chained method calls
</span>path.move_to([<span class="number">8</span>, <span class="number">56</span>]).line_to([<span class="number">32</span>, <span class="number">8</span>]).line_to([<span class="number">56</span>, <span class="number">56</span>]).close();

<span class="comment">// Ensure it is equal to the equivalent SVG path
</span><span class="macro">assert!</span>((<span class="kw-2">&amp;</span>path).commands().eq(<span class="string">"M 8,56 32,8 56,56 Z"</span>.commands()));

<span class="comment">// &amp;Vec&lt;Command&gt; is also valid path data
</span>Mask::new(<span class="kw-2">&amp;</span>path).render(); <span class="comment">// ...</span></code></pre></div>
<p>Here, a vector of <a href="enum.Command.html" title="enum zeno::Command"><code>Command</code></a>s is used to store the path data and the
<a href="trait.PathBuilder.html" title="trait zeno::PathBuilder"><code>PathBuilder</code></a> trait provides the extension methods necessary for
building a path.</p>
<p>Beyond the four basic path commands, the path builder trait also provides
arcs (and position relative versions of all previous commands) along with
rectangles, round rectangles, ellipses and circles:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Angle, ArcSize, ArcSweep, Command, PathBuilder, PathData};

<span class="kw">let </span><span class="kw-2">mut </span>path: Vec&lt;Command&gt; = Vec::new();

path.move_to([<span class="number">1</span>, <span class="number">2</span>]).rel_arc_to(
    <span class="number">8.0</span>,
    <span class="number">4.0</span>,
    Angle::from_degrees(<span class="number">30.0</span>),
    ArcSize::Small,
    ArcSweep::Positive,
    [<span class="number">10</span>, <span class="number">4</span>],
);

<span class="macro">assert!</span>((<span class="kw-2">&amp;</span>path).commands().eq(<span class="string">"M1,2 a8,4,30,0,1,10,4"</span>.commands()));</code></pre></div>
<p>Along with incremental building of paths, path builder can also be used as a
“sink” for capturing the result of the application of a style and transform
to some path data. For example, it is possible to store the output of a stroke
style to avoid the cost of stroke evaluation for future rendering or hit test
operations with the use of the <a href="fn.apply.html" title="fn zeno::apply"><code>apply</code></a> function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{apply, Cap, Command, PathBuilder, PathData, Stroke};

<span class="kw">let </span><span class="kw-2">mut </span>stroke: Vec&lt;Command&gt; = Vec::new();

apply(<span class="string">"L10,0"</span>, Stroke::new(<span class="number">4.0</span>).cap(Cap::Round), <span class="prelude-val">None</span>, <span class="kw-2">&amp;mut </span>stroke);</code></pre></div>
<p><a href="trait.PathBuilder.html" title="trait zeno::PathBuilder"><code>PathBuilder</code></a> is only implemented for <code>Vec&lt;Command&gt;</code> by default, but
custom implementations are possible to support capturing and building
paths into other data structures.</p>
<h2 id="traversal"><a class="doc-anchor" href="#traversal">§</a>Traversal</h2>
<p>Path traversal involves incremental evaluation of a path by some metric. This
crate currently provides two methods of traversal.</p>
<p>The <a href="struct.Vertices.html" title="struct zeno::Vertices"><code>Vertices</code></a> iterator yields a variant of the <a href="enum.Vertex.html" title="enum zeno::Vertex"><code>Vertex</code></a> enum at the
beginning and end of each subpath and between each path command. Each variant
provides all the geometric information necessary to place SVG style markers.</p>
<p>The <a href="struct.Walk.html" title="struct zeno::Walk"><code>Walk</code></a> type is an iterator-like type that allows for
stepping along the path by arbitrary distances. Each step yields the position
on the path at the next distance along with a vector describing the
left-ward direction from the path at that point. This is useful for animating
objects along a path, or for rendering text attached to a path.</p>
<h2 id="transient-memory-allocations"><a class="doc-anchor" href="#transient-memory-allocations">§</a>Transient memory allocations</h2>
<p>The algorithms in this crate make a concerted effort to avoid dynamic
allocations where possible, but paths of significant size or complexity
may cause spills into temporary heap memory. Specifically, stroke evaluation
and rasterization may cause heap allocations.</p>
<p>To amortize the cost of these, the appropriately named
<a href="struct.Scratch.html" title="struct zeno::Scratch"><code>Scratch</code></a> struct is available. This type contains internal
heap allocated storage and provides replacement methods for functions that may
allocate. In addition, the <a href="struct.Mask.html#method.with_scratch" title="associated function zeno::Mask::with_scratch"><code>Mask::with_scratch</code></a> and <a href="struct.HitTest.html#method.with_scratch" title="associated function zeno::HitTest::with_scratch"><code>HitTest::with_scratch</code></a>
constructors are provided which take a scratch instance as an argument and
redirect all transient allocations to the reusable storage.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Angle.html" title="struct zeno::Angle">Angle</a></dt><dd>Represents an angle in degrees or radians.</dd><dt><a class="struct" href="struct.Bounds.html" title="struct zeno::Bounds">Bounds</a></dt><dd>Axis-aligned bounding box.</dd><dt><a class="struct" href="struct.HitTest.html" title="struct zeno::HitTest">HitTest</a></dt><dd>Builder for configuring and executing a hit test.</dd><dt><a class="struct" href="struct.Mask.html" title="struct zeno::Mask">Mask</a></dt><dd>Builder for configuring and rendering a mask.</dd><dt><a class="struct" href="struct.Placement.html" title="struct zeno::Placement">Placement</a></dt><dd>Describes the offset and dimensions of a rendered mask.</dd><dt><a class="struct" href="struct.Scratch.html" title="struct zeno::Scratch">Scratch</a></dt><dd>Scratch memory for reusable heap allocations.</dd><dt><a class="struct" href="struct.Stroke.html" title="struct zeno::Stroke">Stroke</a></dt><dd>Describes the visual style of a stroke.</dd><dt><a class="struct" href="struct.Transform.html" title="struct zeno::Transform">Transform</a></dt><dd>Two dimensional transformation matrix.</dd><dt><a class="struct" href="struct.Vector.html" title="struct zeno::Vector">Vector</a></dt><dd>Two dimensional vector.</dd><dt><a class="struct" href="struct.Vertices.html" title="struct zeno::Vertices">Vertices</a></dt><dd>An iterator over the vertices of a path.</dd><dt><a class="struct" href="struct.Walk.html" title="struct zeno::Walk">Walk</a></dt><dd>An iterator like type that walks along a path by arbitrary steps.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.ArcSize.html" title="enum zeno::ArcSize">ArcSize</a></dt><dd>Describes the size of an arc.</dd><dt><a class="enum" href="enum.ArcSweep.html" title="enum zeno::ArcSweep">ArcSweep</a></dt><dd>Describes the sweep direction for an arc.</dd><dt><a class="enum" href="enum.Cap.html" title="enum zeno::Cap">Cap</a></dt><dd>Defines the shape to be drawn at the beginning or end of a stroke.</dd><dt><a class="enum" href="enum.Command.html" title="enum zeno::Command">Command</a></dt><dd>Path command.</dd><dt><a class="enum" href="enum.Fill.html" title="enum zeno::Fill">Fill</a></dt><dd>Describes the visual style of a fill.</dd><dt><a class="enum" href="enum.Format.html" title="enum zeno::Format">Format</a></dt><dd>The desired output image format for rendering.</dd><dt><a class="enum" href="enum.Join.html" title="enum zeno::Join">Join</a></dt><dd>Defines the connection between two segments of a stroke.</dd><dt><a class="enum" href="enum.Origin.html" title="enum zeno::Origin">Origin</a></dt><dd>The origin of the coordinate system for rendering.</dd><dt><a class="enum" href="enum.Style.html" title="enum zeno::Style">Style</a></dt><dd>Represents the style of a path for rendering or hit testing.</dd><dt><a class="enum" href="enum.Verb.html" title="enum zeno::Verb">Verb</a></dt><dd>Action of a path command.</dd><dt><a class="enum" href="enum.Vertex.html" title="enum zeno::Vertex">Vertex</a></dt><dd>A vertex of a path.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.PathBuilder.html" title="trait zeno::PathBuilder">Path<wbr>Builder</a></dt><dd>Trait for types that accept path commands.</dd><dt><a class="trait" href="trait.PathData.html" title="trait zeno::PathData">Path<wbr>Data</a></dt><dd>Trait for types that represent path data.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.apply.html" title="fn zeno::apply">apply</a></dt><dd>Applies the style and transform to the path and emits the result to the
specified sink.</dd><dt><a class="fn" href="fn.bounds.html" title="fn zeno::bounds">bounds</a></dt><dd>Computes the bounding box of the path.</dd><dt><a class="fn" href="fn.length.html" title="fn zeno::length">length</a></dt><dd>Computes the total length of the path.</dd><dt><a class="fn" href="fn.validate_svg.html" title="fn zeno::validate_svg">validate_<wbr>svg</a></dt><dd>Returns an error indicating the first position of invalid SVG path data.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.Point.html" title="type zeno::Point">Point</a></dt><dd>Alias for vector to distinguish intended use.</dd></dl></section></div></main></body></html>