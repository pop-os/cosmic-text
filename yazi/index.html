<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Yet another zlib implementation."><title>yazi - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="yazi" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../yazi/index.html">yazi</a><span class="version">0.2.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#quick-start" title="Quick Start">Quick Start</a></li><li><a href="#compression" title="Compression">Compression</a></li><li><a href="#decompression" title="Decompression">Decompression</a></li><li><a href="#implementation-notes" title="Implementation Notes">Implementation Notes</a></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>yazi</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/yazi/lib.rs.html#1-440">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Yet another zlib implementation.</p>
<p>This crate is an implementation of the RFC 1950 DEFLATE specification with
support for the zlib wrapper. There are many fine options for such in the
Rust ecosystem, but I was looking for one that was small and relatively
simple with reasonable performance/compression ratio and support for heap-free
compression/decompression scenarios. This crate aims to tick those boxes
while also providing composable streaming support based on the standard I/O
mechanisms.</p>
<p>See the quick start guide below for basic usage or jump to the <a href="#compression">compression</a>
or <a href="#decompression">decompression</a> section for more detail.</p>
<h2 id="quick-start"><a class="doc-anchor" href="#quick-start">§</a>Quick Start</h2>
<p>So you’ve got some bytes, they all fit in memory, you don’t need to reuse allocations,
and you just want to compress or decompress them. This section is for you.</p>
<p>Cargo.toml:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
yazi = &quot;0.1.4&quot;</code></pre></div>
<p>The <a href="fn.compress.html" title="fn yazi::compress"><code>compress</code></a> and <a href="fn.decompress.html" title="fn yazi::decompress"><code>decompress</code></a> functions are provided for the most common use cases:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yazi::<span class="kw-2">*</span>;
<span class="comment">// Your source data.
</span><span class="kw">let </span>data = <span class="kw-2">&amp;</span>(<span class="number">0</span>..=<span class="number">255</span>).cycle().take(<span class="number">8192</span>).collect::&lt;Vec&lt;u8&gt;&gt;()[..];
<span class="comment">// Compress it into a Vec&lt;u8&gt; with a zlib wrapper using the default compression level.
</span><span class="kw">let </span>compressed = compress(data, Format::Zlib, CompressionLevel::Default).unwrap();
<span class="comment">// Decompress it into a Vec&lt;u8&gt;.
</span><span class="kw">let </span>(decompressed, checksum) = decompress(<span class="kw-2">&amp;</span>compressed, Format::Zlib).unwrap();
<span class="comment">// Verify the checksum.
</span><span class="macro">assert_eq!</span>(Adler32::from_buf(<span class="kw-2">&amp;</span>decompressed).finish(), checksum.unwrap());
<span class="comment">// Verify that the decompressed data matches the original.
</span><span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>decompressed[..], data);</code></pre></div>
<p>Read on for more detailed usage.</p>
<h2 id="compression"><a class="doc-anchor" href="#compression">§</a>Compression</h2>
<p>To compress data, you’ll need to create an instance of the <a href="struct.Encoder.html" title="struct yazi::Encoder"><code>Encoder</code></a> struct.
The <a href="struct.Encoder.html#method.new" title="associated function yazi::Encoder::new"><code>new</code></a> method can be used to construct an encoder on the
stack, but the internal buffers are large (~300k) and may cause a stack overflow
so it is advisable to use the <a href="struct.Encoder.html#method.boxed" title="associated function yazi::Encoder::boxed"><code>boxed</code></a> method to allocate
the encoder on the heap.</p>
<p>Newly constructed encoders are configured to output a raw DEFLATE bitstream using a
medium compression level and a default strategy. Call <a href="struct.Encoder.html#method.set_format" title="method yazi::Encoder::set_format"><code>set_format</code></a>
to change the output <a href="enum.Format.html" title="enum yazi::Format"><code>Format</code></a>. Raw DEFLATE and zlib are supported. The
<a href="struct.Encoder.html#method.set_level" title="method yazi::Encoder::set_level"><code>set_level</code></a> method allows you to choose the preferred
<a href="enum.CompressionLevel.html" title="enum yazi::CompressionLevel"><code>CompressionLevel</code></a> from a set of basic options or a specific level between 1 and 10.
The <a href="enum.CompressionStrategy.html" title="enum yazi::CompressionStrategy"><code>CompressionStrategy</code></a> can be changed with the <a href="struct.Encoder.html#method.set_strategy" title="method yazi::Encoder::set_strategy"><code>set_strategy</code></a>
method. This allows you to, for example, force the encoder to output only static blocks.</p>
<p>To create an encoder that outputs a zlib bitstream and spends some extra time to potentially
produce a result with a higher compression ratio:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yazi::{CompressionLevel, Encoder, Format};
<span class="kw">let </span><span class="kw-2">mut </span>encoder = Encoder::boxed();
encoder.set_format(Format::Zlib);
encoder.set_level(CompressionLevel::BestSize);</code></pre></div>
<p>The encoder itself does not provide any functionality. It simply stores state and
configuration. To actually compress data, you’ll need an <a href="struct.EncoderStream.html" title="struct yazi::EncoderStream"><code>EncoderStream</code></a>. A stream
is a binding between an encoder and some specific output that will receive the
compressed data. This design allows an encoder to be reused with different types
of outputs without paying the allocation and initialization cost each time.</p>
<p>Streaming supports outputs of the following forms:</p>
<ul>
<li>Fixed buffers, created with the <a href="struct.Encoder.html#method.stream_into_buf" title="method yazi::Encoder::stream_into_buf"><code>stream_into_buf</code></a> method.</li>
<li>Vectors, created with the <a href="struct.Encoder.html#method.stream_into_vec" title="method yazi::Encoder::stream_into_vec"><code>stream_into_vec</code></a> method.</li>
<li>Any type that implements <a href="https://doc.rust-lang.org/1.90.0/std/io/trait.Write.html" title="trait std::io::Write"><code>std::io::Write</code></a>, created with the generic
<a href="struct.Encoder.html#method.stream" title="method yazi::Encoder::stream"><code>stream</code></a> method.</li>
</ul>
<p>Once you have an <a href="struct.EncoderStream.html" title="struct yazi::EncoderStream"><code>EncoderStream</code></a>, simply call <a href="struct.EncoderStream.html#method.write" title="method yazi::EncoderStream::write"><code>write</code></a> one
or more times, feeding your raw data into the stream. If available, you can submit
the entire input buffer at once, or in arbitrarily sized chunks down to a single
byte. After all data has been written, call <a href="struct.EncoderStream.html#method.finish" title="method yazi::EncoderStream::finish"><code>finish</code></a> on
the stream which will consume it, flush all remaining input and output, and
finalize the operation. The finish method returns a <a href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a> containing the
total number of compressed bytes written to the output on success, or an
<a href="enum.Error.html" title="enum yazi::Error"><code>Error</code></a> describing the problem on failure.</p>
<p>Let’s write a function that compresses some arbitrary bytes into a vector:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>compress_bytes(buf: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;Vec&lt;u8&gt;, yazi::Error&gt; {
    <span class="kw">use </span>yazi::Encoder;
    <span class="kw">let </span><span class="kw-2">mut </span>encoder = Encoder::boxed();
    <span class="kw">let </span><span class="kw-2">mut </span>vec = Vec::new();
    <span class="kw">let </span><span class="kw-2">mut </span>stream = encoder.stream_into_vec(<span class="kw-2">&amp;mut </span>vec);
    stream.write(buf)<span class="question-mark">?</span>;
    stream.finish()<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(vec)
}</code></pre></div>
<p>Now let’s do something a bit more interesting, and given two paths, compress
one file into another:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>compress_file(source: <span class="kw-2">&amp;</span>str, dest: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;u64, yazi::Error&gt; {
    <span class="kw">use </span>yazi::Encoder;
    <span class="kw">use </span>std::fs::File;
    <span class="kw">use </span>std::io::{copy, BufWriter};
    <span class="kw">let </span><span class="kw-2">mut </span>encoder = Encoder::boxed();
    <span class="comment">// yazi does not perform any internal buffering beyond what is necessary
    // for correctness.
    </span><span class="kw">let </span><span class="kw-2">mut </span>target = BufWriter::new(File::create(dest)<span class="question-mark">?</span>);
    <span class="kw">let </span><span class="kw-2">mut </span>stream = encoder.stream(<span class="kw-2">&amp;mut </span>target);
    copy(<span class="kw-2">&amp;mut </span>File::open(source)<span class="question-mark">?</span>, <span class="kw-2">&amp;mut </span>stream)<span class="question-mark">?</span>;
    stream.finish()
}</code></pre></div>
<p>Here, we can see that <a href="struct.EncoderStream.html" title="struct yazi::EncoderStream"><code>EncoderStream</code></a> also implements <a href="https://doc.rust-lang.org/1.90.0/std/io/trait.Write.html" title="trait std::io::Write"><code>std::io::Write</code></a>, so we
can pass it directly to <a href="https://doc.rust-lang.org/1.90.0/std/io/copy/fn.copy.html" title="fn std::io::copy::copy"><code>std::io::copy</code></a>. This allows streams to be composable
with the standard I/O facilities and other libraries that support those interfaces.</p>
<h2 id="decompression"><a class="doc-anchor" href="#decompression">§</a>Decompression</h2>
<p>If you’ve already read the section on compression, the API for decompression
is essentially identical with the types replaced by <a href="struct.Decoder.html" title="struct yazi::Decoder"><code>Decoder</code></a> and <a href="struct.DecoderStream.html" title="struct yazi::DecoderStream"><code>DecoderStream</code></a>.
The documentation is copied here almost verbatim for the sake of completeness and for
those who might have skipped directly to this section.</p>
<p>To decompress data, you’ll need to create an instance of the <a href="struct.Decoder.html" title="struct yazi::Decoder"><code>Decoder</code></a> struct.
The <a href="struct.Decoder.html#method.new" title="associated function yazi::Decoder::new"><code>new</code></a> method can be used to construct a decoder on the stack,
and unlike encoders, the decoder struct is relatively small (~10k) and generally
safe to stack allocate. You can create a decoder on the heap with the
<a href="struct.Decoder.html#method.boxed" title="associated function yazi::Decoder::boxed"><code>boxed</code></a> method if you prefer.</p>
<p>Newly constructed decoders are configured to decompress a raw DEFLATE bitstream. Call
<a href="struct.Decoder.html#method.set_format" title="method yazi::Decoder::set_format"><code>set_format</code></a> to change the input <a href="enum.Format.html" title="enum yazi::Format"><code>Format</code></a>. Raw DEFLATE and
zlib are supported. No other configuration is necessary for decompression.</p>
<p>To create a decoder that decompresses a zlib bitstream:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yazi::{Decoder, Format};
<span class="kw">let </span><span class="kw-2">mut </span>decoder = Decoder::new();
decoder.set_format(Format::Zlib);</code></pre></div>
<p>The decoder itself does not provide any functionality. It simply stores state and
configuration. To actually decompress data, you’ll need a
<a href="struct.DecoderStream.html" title="struct yazi::DecoderStream"><code>DecoderStream</code></a>. A stream is a binding between a
decoder and some specific output that will receive the decompressed data. This
design allows a decoder to be reused with different types of outputs without paying the
allocation and initialization cost each time.</p>
<p>Streaming supports outputs of the following forms:</p>
<ul>
<li>Fixed buffers, created with the <a href="struct.Decoder.html#method.stream_into_buf" title="method yazi::Decoder::stream_into_buf"><code>stream_into_buf</code></a> method.</li>
<li>Vectors, created with the <a href="struct.Decoder.html#method.stream_into_vec" title="method yazi::Decoder::stream_into_vec"><code>stream_into_vec</code></a> method.</li>
<li>Any type that implements <a href="https://doc.rust-lang.org/1.90.0/std/io/trait.Write.html" title="trait std::io::Write"><code>std::io::Write</code></a>, created with the generic
<a href="struct.Decoder.html#method.stream" title="method yazi::Decoder::stream"><code>stream</code></a> method.</li>
</ul>
<p>Once you have a <a href="struct.DecoderStream.html" title="struct yazi::DecoderStream"><code>DecoderStream</code></a>, simply call <a href="struct.DecoderStream.html#method.write" title="method yazi::DecoderStream::write"><code>write</code></a> one or
more times, feeding your compressed data into the stream. If available, you can submit
the entire input buffer at once, or in arbitrarily sized chunks down to a single byte.
After all data has been written, call <a href="struct.DecoderStream.html#method.finish" title="method yazi::DecoderStream::finish"><code>finish</code></a> on the stream
which will consume it, flush all remaining input and output, and finalize the operation.
The finish method returns a <a href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a> containing the total number of decompressed bytes
written to the output along with an optional Adler-32 checksum (if the stream was
zlib-encoded) on success, or an <a href="enum.Error.html" title="enum yazi::Error"><code>Error</code></a> describing the problem on failure.</p>
<p>Let’s write a function that decompresses a zlib bitstream into a vector and verifies
the checksum:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>decompress_zlib(buf: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;Vec&lt;u8&gt;, yazi::Error&gt; {
    <span class="kw">use </span>yazi::{Adler32, Decoder, Error, Format};
    <span class="kw">let </span><span class="kw-2">mut </span>decoder = Decoder::new();
    decoder.set_format(Format::Zlib);
    <span class="kw">let </span><span class="kw-2">mut </span>vec = Vec::new();
    <span class="kw">let </span><span class="kw-2">mut </span>stream = decoder.stream_into_vec(<span class="kw-2">&amp;mut </span>vec);
    stream.write(buf)<span class="question-mark">?</span>;
    <span class="comment">// checksum is an Option&lt;u32&gt;
    </span><span class="kw">let </span>(<span class="kw">_</span>, checksum) = stream.finish()<span class="question-mark">?</span>;
    <span class="kw">if </span>Adler32::from_buf(<span class="kw-2">&amp;</span>vec).finish() != checksum.unwrap() {
        <span class="kw">return </span><span class="prelude-val">Err</span>(Error::InvalidBitstream);
    }
    <span class="prelude-val">Ok</span>(vec)
}</code></pre></div>
<p>Now let’s do something a bit more interesting, and given two paths, decompress
one file into another:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>decompress_file(source: <span class="kw-2">&amp;</span>str, dest: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;(u64, <span class="prelude-ty">Option</span>&lt;u32&gt;), yazi::Error&gt; {
    <span class="kw">use </span>yazi::Decoder;
    <span class="kw">use </span>std::fs::File;
    <span class="kw">use </span>std::io::{copy, BufWriter};
    <span class="kw">let </span><span class="kw-2">mut </span>decoder = Decoder::new();
    <span class="comment">// yazi does not perform any internal buffering beyond what is necessary
    // for correctness.
    </span><span class="kw">let </span><span class="kw-2">mut </span>target = BufWriter::new(File::create(dest)<span class="question-mark">?</span>);
    <span class="kw">let </span><span class="kw-2">mut </span>stream = decoder.stream(<span class="kw-2">&amp;mut </span>target);
    copy(<span class="kw-2">&amp;mut </span>File::open(source)<span class="question-mark">?</span>, <span class="kw-2">&amp;mut </span>stream)<span class="question-mark">?</span>;
    stream.finish()
}</code></pre></div>
<p>Here, we can see that <a href="struct.DecoderStream.html" title="struct yazi::DecoderStream"><code>DecoderStream</code></a> also implements <a href="https://doc.rust-lang.org/1.90.0/std/io/trait.Write.html" title="trait std::io::Write"><code>std::io::Write</code></a>, so we can
pass it directly to <a href="https://doc.rust-lang.org/1.90.0/std/io/copy/fn.copy.html" title="fn std::io::copy::copy"><code>std::io::copy</code></a>. This allows streams to be composable with the
standard I/O facilities and other libraries that support those interfaces.</p>
<h2 id="implementation-notes"><a class="doc-anchor" href="#implementation-notes">§</a>Implementation Notes</h2>
<p>The compressor is based heavily on both <a href="https://github.com/richgel999/miniz">miniz</a>
by Rich Geldreich and <a href="https://github.com/Frommi/miniz_oxide">miniz_oxide</a>
by Frommi. The available compression levels and strategies are the same and
it should produce an identical bitstream for a given set of options. The
decompressor is based on the techniques in <a href="https://github.com/ebiggers/libdeflate">libdeflate</a>
by Eric Biggers.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Adler32.html" title="struct yazi::Adler32">Adler32</a></dt><dd>Rolling Adler-32 checksum.</dd><dt><a class="struct" href="struct.Decoder.html" title="struct yazi::Decoder">Decoder</a></dt><dd>Stateful context for decompression.</dd><dt><a class="struct" href="struct.DecoderStream.html" title="struct yazi::DecoderStream">Decoder<wbr>Stream</a></dt><dd>Decompression stream combining a decoder context with an output.</dd><dt><a class="struct" href="struct.Encoder.html" title="struct yazi::Encoder">Encoder</a></dt><dd>Stateful context for compression.</dd><dt><a class="struct" href="struct.EncoderStream.html" title="struct yazi::EncoderStream">Encoder<wbr>Stream</a></dt><dd>Compression stream combining an encoder context with an output.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.CompressionLevel.html" title="enum yazi::CompressionLevel">Compression<wbr>Level</a></dt><dd>The level of compression– a compromise between speed and size.</dd><dt><a class="enum" href="enum.CompressionStrategy.html" title="enum yazi::CompressionStrategy">Compression<wbr>Strategy</a></dt><dd>Selects between various specialized compressor modes.</dd><dt><a class="enum" href="enum.Error.html" title="enum yazi::Error">Error</a></dt><dd>Errors that may occur during compression or decompression.</dd><dt><a class="enum" href="enum.Format.html" title="enum yazi::Format">Format</a></dt><dd>Defines the format for a compressed bitstream.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.compress.html" title="fn yazi::compress">compress</a></dt><dd>Compresses a buffer into a vector with the specified format and
compression level.</dd><dt><a class="fn" href="fn.decompress.html" title="fn yazi::decompress">decompress</a></dt><dd>Decompresses a buffer of the specified format into a vector.</dd></dl></section></div></main></body></html>